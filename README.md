# PDA-Project

Language L = {an bn | n >= 0} <br>
generated by context free grammar G = ({a,b,S}, {a,b}, R, S)
&emsp;  where R contains rules S->aSb and S->e <br>
The resulting PDA is <br>
&emsp;  M1 = ({p,q,qa,qb,q$}, {a,b}, {a,b,S}, rules, p, {q$}) <br>
  where rules = <br>
  &emsp;    1 (p,e,e)  -> (q,S) <br>
&emsp;      2 (q,a,e)  -> (qa,e) <br>
&emsp;      3 (qa,e,a) -> (q,e) <br>
&emsp;      4 (q,b,e)  -> (qb,e) <br>
&emsp;      5 (qb,e,b) -> (q,e) <br>
&emsp;      6 (q,$,e)  -> (q$,e) <br>
&emsp;      7 (qa,e,S) -> (qa,aSb) <br>
&emsp;      8 (qb,e,S) -> (qb,e) <br>

<br>
//using queue because it makes more sense: eg. string aaabbb$ we gonna be putting the "a's" first then the "b's", we will also be
//getting rid of the "a's" first then the "b's" --> queues follow FIFO
using queue for unread input 

//stack because last LIFO
Using stack for new input
<br> <br>
Main -> fuction takes 3 inputs -> returns rule used -> apply rule in separate function -> print line
In each rule function 
  If the unread input is empty
  
  While loop condition is unread input is empty
  
  ----------------------------------------------------------------HEADERS------------------------------------------------------------------------
  <br>
  #include <iostream>
  #include <string>
  #include <queue>
  #include <stack>
  
  using namespace std;
  
  ------------------------------------------------------------------FUNCTION DECLARATIONS-------------------------------------------------------
  //asks for n
  //returns n
  int take_input();
  
  //initializes queue (unread input) to an bn $
  //parameter: int n
  //returns the initialized queue of form a^n b^n $
  queue<char> init_queue(int n);
  
  //print the current queue
  //parameter: the unread queue
  void print_queue (queue<char> q);
  
  //print stack
  //parameter: the current stack
  void print_stack (stack<char> s);
  
  //find rule function
  //parameters: current state - string, unread input - queue, stack - stack
  //returns an int (1-8) which corresponds to which rule to use
  int find_rule(string &state, queue<char> unread, stack<char> stack);
  

  ---------------------------------------------------------------------MAIN----------------------------------------------------------------------
  Main{
    //take input
    int n;
    n = take_input();
    
    //initialize step = 0, initial state = p
    int step = 0;
    string state = p;
    
    //intializing queue with a's b's
    queue<char> unread = init_queue(n);
    
    //creating an empty stack
    stack<char> stack;
    
    //variable to keep track of the current rule being used
    int rule;
  
    //gonna need a variable with the R rule used (i.e. rules 7 and 8)
    //alternatively could just make a cout statement for that within that rule in the apply rule function
  
  
  
    
    do {
  
    //-------- TO DO -------
    //rule = applyRules(state, read, unread)

    
  
  
  
  
    }while(!unread.empty() && !stack.empty());
  
  
  applyRules(state, read, unread){
      rule = findRules();
      applyrule   
  }
  ------------------------------------------------------------FUNCTION DEFINITIONS--------------------------------------------------------------
  
  int take_input()
  {
    int n;
    
    do {
    cout << "Enter n (n>=0): ";
    cin >> n;
    } while(n<0);
    
    return n;
  }
  
  queue<char> init_queue(int n)
  {
    queue<char> q;
    for (int i=0; i<n; i++)
      q.push('a');
    
    for (int i=0; i<n; i++)
      q.push('b');

    q.push('$');
  
    return q;
  }
  
  void print_queue (queue<char> q)
  {
    //creating a temp queue = unread_queue, so that our unread_queue stays the same
    queue<char> temp = q;
    while(!temp.empty())
    {
      cout << temp.front() << " ";
      temp.pop();
    }
    // might need to add a "tab" here for formatting the table after the unread queue has been displayed
  }
  
  void print_stack (stack<char> s)
  {
    // creating a temp stack as to not alter the values in our stack
    stack<char> temp = s;
    while (!s.empty())
    {
      cout << s.top();
      s.pop();
    }
  }
  
  int find_rule(string &state, queue<char> unread, stack<char> stack)
  {
  
    //row of if statements (if yall have better ideas then we should do it)
    //we could also just change this function to make the changes directly
    //instead of having another one -- it can still return an int of the rule used (thoughts?)

    // rule 1
    if (state == "p")
      return 1;
  
    //rule 2
    else if (state == "q" && unread == 'a')
      return 2;
  
    //rule 3
    else if (state == "qa" && stack == 'a')
      return 3;
   
    //rule 4
    else if (state == "q" && unread == 'b')
      return 4;
  
    //rule 5
    else if (state == "qb" && stack = 'b')
      return 5;
  
    //rule 6
    else if (state == "q" && unread = '$')
      return 6;
    
    //rule 7
    else if (state == "qa" && stack = 'S')
      return 7;
  
    //rule 8
    else(state == "qb" && stack = 'S')
      return 8
  }
  
  
//TODO  
  FindRules
  
  ApplyRule1{
    pop
    push 
    set new state
    print line
    step++
  }
  ApplyRule2
  
  
   
  
